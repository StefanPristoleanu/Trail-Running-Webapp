# * * * Spring boot - REST - JPA database - maven * * * #

# create a new java maven project using pom.xml generated with:

# Spring Initializr:
https://start.spring.io/

# and check: Jersey (JAX-RS), JPA, MySQL, H2, JDBC, PostgreSQL, Web
# load maven project (pom.xml) 

# - in NetBeans also add "NB SpringBoot" plugin: nb-springboot
https://github.com/AlexFalappa/nb-springboot

# - or in Eclipse Marketplace -> install Spring Tools (is in Popular Tab) and restart Eclipse


### add REST web service method using NetBeans -> Spring Framework -> Rest Controller Class:
@RestController
@RequestMapping("/rest")
# - for more info check:
https://www.shortn0tes.com/2018/01/spring-boot-web-app-intellij-idea-community.html
https://blog.jetbrains.com/idea/2018/04/spring-and-spring-boot-in-intellij-idea-2018-1/
https://spring.io/guides/gs/accessing-data-rest/
https://www.leveluplunch.com/java/tutorials/014-post-json-to-spring-rest-webservice/


### use JPA for database:
https://spring.io/guides/gs/accessing-data-mysql/
# In the sources folder, create a resource file src/main/resources/application.properties
# and update the spring.datasource.url with your path to the home user: 

spring.jpa.hibernate.ddl-auto=none
spring.datasource.url=jdbc:h2:/Users/stefan/h2db_test;AUTO_SERVER=TRUE;CACHE_SIZE=262144;AUTO_SERVER_PORT=9498
spring.datasource.username=sa
spring.datasource.password=sa

# Here, spring.jpa.hibernate.ddl-auto can be none, update, create, create-drop, refer to the Hibernate documentation for details.

# create test1 table with the corresponding sql (see TestDbTable1.java) or use: spring.jpa.hibernate.ddl-auto=create


# 1. in NetBeans -> Services tab -> Databases add a new connection to H2 (or any other database server) with:
jdbc:h2:~/h2db_test;MODE=PostgreSQL;AUTO_SERVER=TRUE;CACHE_SIZE=262144;AUTO_SERVER_PORT=9498 

# 2. in NetBeans create new Entity Class from Database connection
#-- Note: a NUMERIC field in database will be automatically converted into a BigDecimal java type which can be replaced with Long !
# for PK with Auto Increment use:
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Basic(optional = false)
    @Column(name = "ID")
    private Long id;
    

# [2.] -- in Eclipse: create new JPA project and choose the previous db connection and the corresponding Catalog and Schema
    - then create JPA Entities from Tables
    - and copy the new generated classes in the spring project 
    

# 3. in NetBeans create new Spring Framework - Repository Interface using as Base Interface: CrudRepository
# and for Entity: the previously created Entity class: TestDbTable1
    // This will be AUTO IMPLEMENTED by Spring into a Bean called table1Repository
    // CRUD refers Create, Read, Update, Delete
# - update the PK type in interface:
    public interface Table1Repository extends CrudRepository<TestDbTable1, Long> {
    }

# 4. Create a new REST controller with "Generate CRUD Methods" and add in class:
    @Autowired // This means to get the bean called table1Repository
	           // Which is auto-generated by Spring, we will use it to handle the data
	private Table1Repository table1Repository;
// [...]

# - add REST API method for add new record:
    /*
    curlj http://localhost:8080/db-table1/addNew -d '{"accessToken":1, "testName":"test1", "info" : "info 1 ..."}'
    */
    @PostMapping(value = "/addNew", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    public ResponseEntity<?> addNew(@RequestBody String request) {
        try {
            JSONObject jsonRequest = new JSONObject(request);
            TestDbTable1 newRec = new TestDbTable1();
            if (jsonRequest.has("testName")) {
                newRec.setTestName(jsonRequest.getString("testName"));
            } else {
                String testName = "test-" + UUID.randomUUID().toString();
                newRec.setTestName(testName);
            }
            newRec.setUpdateCounter(0);
            newRec.setLastUpdate(new java.sql.Timestamp(System.currentTimeMillis()));//new java.util.Date());
            // ToDo - update other fields ...
            table1Repository.save(newRec);
            JSONObject jsonResponse = new JSONObject();
            jsonResponse.put("responseCode", 0);
            jsonResponse.put("message", "OK add new record in TestTable1 for testName: " + newRec.getTestName());
            jsonResponse.put("ID", newRec.getId());
            return new ResponseEntity(jsonResponse.toString(), HttpStatus.OK);
        } catch (JSONException ex) {
            Logger.getLogger(TestRestController.class.getName()).log(Level.SEVERE, null, ex.toString());
            return new ResponseEntity(ex.toString(), HttpStatus.BAD_REQUEST);
        }
    }// end addNew
 
# 5. - add REST API method for update record:    
    /*
    curlj http://localhost:8080/db-table1/update -d '{"accessToken":1, "id":1, "info" : "info !"}'
    */
    @PostMapping(value = "/update", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    public ResponseEntity<?> update(@RequestBody String request) {
        try {
            JSONObject jsonRequest = new JSONObject(request);
            if (!jsonRequest.has("ID")) {
                return new ResponseEntity("ID tag not found", HttpStatus.BAD_REQUEST);
            }
            long id = jsonRequest.getLong("ID");
            TestDbTable1 aRec = table1Repository.findById(id).orElse(null);
            if (aRec == null) {
                JSONObject jsonResponse = new JSONObject();
                jsonResponse.put("responseCode", -1);
                jsonResponse.put("message", "Not found a record with ID: " + id);
                return new ResponseEntity(jsonResponse.toString(), HttpStatus.OK);
            }
            if (jsonRequest.has("testName")) {
                aRec.setTestName(jsonRequest.getString("testName"));
            }
            aRec.setUpdateCounter(aRec.getUpdateCounter() + 1);
            aRec.setLastUpdate(new java.sql.Timestamp(System.currentTimeMillis()));
            // ToDo - update other fields ...
            table1Repository.save(aRec);
            JSONObject jsonResponse = new JSONObject();
            jsonResponse.put("responseCode", 0);
            jsonResponse.put("message", "OK updaterecord in TestTable1 for ID: " + id);
            return new ResponseEntity(jsonResponse.toString(), HttpStatus.OK);
        } catch (JSONException ex) {
            Logger.getLogger(TestRestController.class.getName()).log(Level.SEVERE, null, ex.toString());
            return new ResponseEntity(ex.toString(), HttpStatus.BAD_REQUEST);
        }
    }// end update
    
# 6. - add REST API method for query records:
# first add in repository interface (Table1Repository) a new method:
    @Query("SELECT t FROM TestDbTable1 t WHERE (t.id) <= (:idMax)")
    public List<TestDbTable1> query1(@Param("idMax") Long idMax); 

# then add the query method in REST controller class:
    /*
        curl http://localhost:8080/db-table1/query
        curlj http://localhost:8080/db-table1/query?idMax=5
     */
    @GetMapping("/query")
    public Object getQuery(@RequestParam Optional<Long> idMax) {
        try {
            Long idQuery = (long) 2;
            if (idMax.isPresent()) {
                idQuery = idMax.get(); //returns the idMax from path parameter (if exist)
            }
            List<TestDbTable1> recList = table1Repository.query1(idQuery);
            // for quick return with only the query result use teh next line:
            //return new ResponseEntity(recList, HttpStatus.OK);
            // for return more info:
            JSONObject jsonResponse = new JSONObject();
            jsonResponse.put("responseCode", 0);
            jsonResponse.put("message", "OK Query filter by ID <= " + idQuery);
            jsonResponse.put("querySize", recList.size());
            ObjectMapper mapper = new ObjectMapper();
            String jsonList = mapper.writeValueAsString(recList);
            jsonResponse.put("queryData", new JSONArray(jsonList));
            return new ResponseEntity(jsonResponse.toString(), HttpStatus.OK);
        } catch (JsonProcessingException | JSONException ex) {
            Logger.getLogger(TestRestController.class.getName()).log(Level.SEVERE, null, ex.toString());
            return new ResponseEntity(ex.toString(), HttpStatus.BAD_REQUEST);
        }
    }// end getQuery    
    
#--------

# for curl / curlj:

#-- in linux or macOS create a new bash alias "curlj" for curl:
nano ~/.bash_profile 
alias curlj='curl --header "Content-Type: application/json" -w "\n" -v'

source ~/.bash_profile

#-- for json pretty print add at the end of command:  | json_pp


    curlj http://localhost:8080/rest/test2 -d '{"accessToken":1, "request":"test-api"}'
    #- for json pretty print:
    curlj http://localhost:8080/rest/test2 -d '{"accessToken":1, "request":"test-api"}' | json_pp
    
#--------------------------------------

Quick add:
curlj http://localhost:8080/db-table1/addNew -d '{"accessToken":1"}'
