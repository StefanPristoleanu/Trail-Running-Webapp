
# Spring boot - REST - JPA database - maven #
=============================================


## 1. create a new java maven project using pom.xml generated with:##

__Spring Initializr:__
https://start.spring.io/

- and check: Jersey (JAX-RS), JPA, MySQL, H2, JDBC, PostgreSQL, Web
- load maven project (pom.xml) 

- in NetBeans also add "NB SpringBoot" plugin: nb-springboot
https://github.com/AlexFalappa/nb-springboot

- or in Eclipse Marketplace -> install Spring Tools (is in Popular Tab) and restart Eclipse


### add REST web service method using NetBeans -> Spring Framework -> Rest Controller Class:
`
@RestController
@RequestMapping("/rest")
`
**for more info check**:
https://www.shortn0tes.com/2018/01/spring-boot-web-app-intellij-idea-community.html
https://blog.jetbrains.com/idea/2018/04/spring-and-spring-boot-in-intellij-idea-2018-1/
https://spring.io/guides/gs/accessing-data-rest/
https://www.leveluplunch.com/java/tutorials/014-post-json-to-spring-rest-webservice/


### use JPA for database:
https://spring.io/guides/gs/accessing-data-mysql/
### In the sources folder, create a resource file src/main/resources/application.properties
### and update the spring.datasource.url with your path to the home user: 
`
spring.jpa.hibernate.ddl-auto=none
spring.datasource.url=jdbc:h2:/Users/nicu/h2db_test;AUTO_SERVER=TRUE;CACHE_SIZE=262144;AUTO_SERVER_PORT=9498
spring.datasource.username=sa
spring.datasource.password=sa
`
### Here, spring.jpa.hibernate.ddl-auto can be none, update, create, create-drop, refer to the Hibernate documentation for details.

### create test1 table with the corresponding sql (see TestDbTable1.java) or use: spring.jpa.hibernate.ddl-auto=create
- the SQL cmd:
```sql
CREATE TABLE TEST_DB_TABLE_1 (
    id BIGINT NOT NULL AUTO_INCREMENT,
    test_name varchar(100) NOT NULL,
    value NUMERIC,
    update_counter NUMERIC,
    last_update DATETIME NULL,
    info varchar(500) NULL,
    CONSTRAINT test_db_table_pk PRIMARY KEY (id),
    CONSTRAINT test_db_table_un UNIQUE (test_name));
```
__Notice:__ for database tool you can install [DBeaver] (https://dbeaver.io/)

## 2. in NetBeans -> Services tab -> Databases add a new connection to H2 (or any other database server) with:
jdbc:h2:~/h2db_test;MODE=PostgreSQL;AUTO_SERVER=TRUE;CACHE_SIZE=262144;AUTO_SERVER_PORT=9498 

## 3. in NetBeans create new Entity Class from Database connection
### Note: a NUMERIC field in database will be automatically converted into a BigDecimal java type which can be replaced with Long !
__for PK with Auto Increment use__:
```java
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Basic(optional = false)
    @Column(name = "ID")
    private Long id;
```    

## [3.] -- in Eclipse: create new JPA project and choose the previous db connection and the corresponding Catalog and Schema
    - then create JPA Entities from Tables
    - and copy the new generated classes in the spring project 
    

## 4. in NetBeans create new Spring Framework - Repository Interface using as Base Interface: CrudRepository
__and for Entity: the previously created Entity class: TestDbTable1__
    // This will be AUTO IMPLEMENTED by Spring into a Bean called table1Repository
    // CRUD refers Create, Read, Update, Delete
- update the PK type in interface:
```
    public interface Table1Repository extends CrudRepository<TestDbTable1, Long> {
    }
```

## 5. Create a new REST controller with "Generate CRUD Methods" and add in class:
```
    @Autowired // This means to get the bean called table1Repository
	           // Which is auto-generated by Spring, we will use it to handle the data
	private Table1Repository table1Repository;
// [...]
```

### add REST API method for add new record:
__Notice:__ the accessToken tag from json is not used but it would be useful for authentication
```java
    /*
    curlj http://localhost:8080/db-table1/addNew -d '{"accessToken":1, "testName":"test1", "info" : "info 1 ..."}'
    curlj http://localhost:8080/db-table1/addNew -d '{"accessToken":1}'
    */
    @PostMapping(value = "/addNew", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    public ResponseEntity<?> addNew(@RequestBody String request) {
        try {
            JSONObject jsonRequest = new JSONObject(request);
            TestDbTable1 newRec = new TestDbTable1();
            if (jsonRequest.has("testName")) {
                newRec.setTestName(jsonRequest.getString("testName"));
            } else {
                String testName = "test-" + UUID.randomUUID().toString();
                newRec.setTestName(testName);
            }
            newRec.setUpdateCounter(0);
            newRec.setLastUpdate(new java.sql.Timestamp(System.currentTimeMillis()));//new java.util.Date());
            // ToDo - update other fields ...
            table1Repository.save(newRec);
            JSONObject jsonResponse = new JSONObject();
            jsonResponse.put("responseCode", 0);
            jsonResponse.put("message", "OK add new record in TestTable1 for testName: " + newRec.getTestName());
            jsonResponse.put("ID", newRec.getId());
            return new ResponseEntity(jsonResponse.toString(), HttpStatus.OK);
        } catch (JSONException ex) {
            Logger.getLogger(TestRestController.class.getName()).log(Level.SEVERE, null, ex.toString());
            return new ResponseEntity(ex.toString(), HttpStatus.BAD_REQUEST);
        }
    }// end addNew
```
 
## 6. - add REST API method for update record: 
```java   
    /*
    curlj http://localhost:8080/db-table1/update -d '{"accessToken":1, "id":1, "info" : "info !"}'
    */
    @PostMapping(value = "/update", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)
    public ResponseEntity<?> update(@RequestBody String request) {
        try {
            JSONObject jsonRequest = new JSONObject(request);
            if (!jsonRequest.has("ID")) {
                return new ResponseEntity("ID tag not found", HttpStatus.BAD_REQUEST);
            }
            long id = jsonRequest.getLong("ID");
            TestDbTable1 aRec = table1Repository.findById(id).orElse(null);
            if (aRec == null) {
                JSONObject jsonResponse = new JSONObject();
                jsonResponse.put("responseCode", -1);
                jsonResponse.put("message", "Not found a record with ID: " + id);
                return new ResponseEntity(jsonResponse.toString(), HttpStatus.OK);
            }
            if (jsonRequest.has("testName")) {
                aRec.setTestName(jsonRequest.getString("testName"));
            }
            aRec.setUpdateCounter(aRec.getUpdateCounter() + 1);
            aRec.setLastUpdate(new java.sql.Timestamp(System.currentTimeMillis()));
            // ToDo - update other fields ...
            table1Repository.save(aRec);
            JSONObject jsonResponse = new JSONObject();
            jsonResponse.put("responseCode", 0);
            jsonResponse.put("message", "OK updaterecord in TestTable1 for ID: " + id);
            return new ResponseEntity(jsonResponse.toString(), HttpStatus.OK);
        } catch (JSONException ex) {
            Logger.getLogger(TestRestController.class.getName()).log(Level.SEVERE, null, ex.toString());
            return new ResponseEntity(ex.toString(), HttpStatus.BAD_REQUEST);
        }
    }// end update
```
    
## 7. - add REST API method for query records:
- first add in repository interface (Table1Repository) a new method:
```java
    @Query("SELECT t FROM TestDbTable1 t WHERE (t.id) <= (:idMax)")
    public List<TestDbTable1> query1(@Param("idMax") Long idMax); 
```
- then add the query method in REST controller class:
```java
    /*
        curlj http://localhost:8080/db-table1/query
        curlj http://localhost:8080/db-table1/query?idMax=5
     */
    @GetMapping("/query")
    public Object getQuery(@RequestParam Optional<Long> idMax) {
        try {
            Long idQuery = (long) 2;
            if (idMax.isPresent()) {
                idQuery = idMax.get(); //returns the idMax from path parameter (if exist)
            }
            List<TestDbTable1> recList = table1Repository.query1(idQuery);
            // for quick return with only the query result use teh next line:
            //return new ResponseEntity(recList, HttpStatus.OK);
            // for return more info:
            JSONObject jsonResponse = new JSONObject();
            jsonResponse.put("responseCode", 0);
            jsonResponse.put("message", "OK Query filter by ID <= " + idQuery);
            jsonResponse.put("querySize", recList.size());
            ObjectMapper mapper = new ObjectMapper();
            String jsonList = mapper.writeValueAsString(recList);
            jsonResponse.put("queryData", new JSONArray(jsonList));
            return new ResponseEntity(jsonResponse.toString(), HttpStatus.OK);
        } catch (JsonProcessingException | JSONException ex) {
            Logger.getLogger(TestRestController.class.getName()).log(Level.SEVERE, null, ex.toString());
            return new ResponseEntity(ex.toString(), HttpStatus.BAD_REQUEST);
        }
    }// end getQuery    
```

---

## for curl / curlj:

- in linux or macOS create a new bash alias "curlj" for curl:
    - in centos or macos:
    ` nano ~/.bash_profile ` 
    - in debian:
    ` nano ~/.bashrc `
and add at the end:
`
alias curlj='curl --header "Content-Type: application/json" -w "\n" -v'
`
then save and execute in the same terminal:
` source ~/.bash_profile `

** for json pretty print add at the end of command: | json_pp
`
    curlj http://localhost:8080/rest/test2 -d '{"accessToken":1, "request":"test-api"}' | json_pp
`  
---  
- example:
`
    curlj http://localhost:8080/rest/test2 -d '{"accessToken":1, "request":"test-api"}'
    curlj http://localhost:8080/db-table1/addNew -d '{"accessToken":1}'
    curlj http://localhost:8080/db-table1/query?idMax=5  | json_pp
    curlj http://localhost:8080/db-table1/update -d '{"accessToken":1, "id":1, "info" : "my first update !"}'

`   
